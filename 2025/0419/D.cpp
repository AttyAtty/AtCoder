#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main() {
    int n, m;
    cin >> n >> m;
    vector<ll> cnt(n);
    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        cnt[(a + b) % n]++;
    }
    ll ans = (ll)m * (m - 1) / 2;
    for (auto e : cnt) {
        ans -= e * (e - 1) / 2; // 平行な直線ペア数
    }
    cout << ans << endl;
}

// 解説

// 2直線の組はM(M−1)/2通りあります。交わる直線の組の個数を求める問題
// ですが、余事象を考えて交わらない直線の組を数えることを考えます。
// 実際に答えを求めるときは2M(M−1)/2から交わらない直線の組の個数を引けば
// 良いです。2つの直線が交わらないとはその2 つの直線が平行であること
// と同値です。では平行な直線の組を数え上げることではできるでしょうか。

// 直線1と直線2が平行、直線2と直線3げ平行であるとき直線1と直線3も平行
// です。これは傾きが同じ直線は全て互いに平行であるという特徴からも
// わかります。逆に、傾きが異なる2直線は必ず交わります。つまり、
// ある傾きの直線がk 本あるならk(k−1)/2個の平行な直線の組があります。

// 以上より、M 本の直線をその傾きで分類することができれば答え求られ
// ます。実際に分類する方法について考えます。実は、(Ai+Bi)modN で
// 分類することができます。点Aiと点Biを通る直線を取って、点Aiから
// 時計回りにk 個目の点、点Biから反時計回りにk 個目の点を通る直線が
// 点Aiと点Biを通る直線と平行であると考えるとわかりやすいです。

// 実装の際は答えが 32bit整数型ではオーバーフローすることがあるこ
// とに気をつける必要があります。


// 問題文
// 円周上に 
// N 個の点が等間隔に並んでおり、時計回りに1,2,…,N と番号がつけら
// れています。

// M 本の相異なる直線があり、i 本目の直線は異なる2 つの点、点Aiと
// 点Biを通る直線です。(1≤i≤M)

// 以下の2つの条件をともに満たすような整数の組(i,j)の個数を求めてください。

// 1≤i<j≤M
// i 本目の直線と 
// j 本目の直線は交わる
// 制約
// 2≤N≤106
// 1≤M≤3×10 
// 1≤Ai<Bi≤N(1≤i≤M)

// (Ai,Bi)!=(Aj ,Bj)(i!=j)
// 入力は全て整数
// 入力
// 入力は以下の形式で標準入力から与えられる。

// N M
// A1 B1 
// A2 B2
// ⋮
// AM​ BM 
// 出力
// 答えを出力せよ。

// 入力例 1
// Copy
// 8 3
// 1 5
// 1 8
// 2 4
// 出力例 1
// Copy
// 2
// 次の図のように円周上に 
// 8 個の点と 
// 3 本の直線があります。

// 1 本目の直線と 
// 2 本目の直線は交わります。
// 1 本目の直線と 
// 3 本目の直線は交わりません。
// 2 本目の直線と 
// 3 本目の直線は交わります。
// (i,j)=(1,2),(2,3) の 
// 2 つの組が条件を満たすため、
// 2 を出力します。

// 入力例 2
// Copy
// 5 10
// 2 5
// 1 5
// 1 2
// 2 4
// 2 3
// 1 3
// 1 4
// 3 5
// 3 4
// 4 5
// 出力例 2
// Copy
// 40
