N, X = map(int, input().split())
S = [0] * N  # 成功した時に得られるスコア
C = [0] * N  # そのアイテムを使うためのコスト
P = [0] * N  # 成功する確率（あとで 0.○ に直される
for i in range(N):
    S[i], C[i], P[i] = map(int, input().split())
    P[i] /= 100
d = [[0.0 for _ in range(X + 1)] for _ in range(1 << N)]
# d[s][x]：「状態 s（どのアイテムを使ったか）」で「残りコスト x
# のとき」に得られる 期待値の最大値 を格納する配列。
# 1 << N：ビットで「どのアイテムを使ったか」を管理（使った → 1, 使ってない → 0）
# X + 1：残りコストが 0～X の範囲すべて
# d のサイズは → [2^N] 行 × [X + 1] 列
# 初期値は0.0
# 1 << N というのは、「1 を N ビット左にシフトする」という意味
# 数学的には： 1 << N = 2^N なので，
# 実質 range(1 << N) == range(2 ** N)
# これは「2進数で表せる N 桁未満の全パターン


for x in range(X + 1):         # 残りコスト x
    for s in range(1 << N):    # 状態 s（使ったアイテムのビット）
        for i in range(N):     # 次に試すアイテム i
            xx = x - C[i]           # アイテムiのコストを引いた後の残りコスト
            ss = s | (1 << i)       # 状態 s にアイテム i を使ったことを追加した新状態
            #  ビット演算（bit演算） を使って、s という整数に i 番目のビットを立てる（1にする） 操作をしています
            #  # 0b1010 | 0b1000 = 0b1010みたいな感じ．文字列sとibit目だけが1の文字列で比較している．
            if xx < 0 or s == ss:
                continue
            val = P[i] * (d[ss][xx] + S[i]) + (1 - P[i]) * d[s][xx]
            d[s][x] = max(d[s][x], val)
print(d[0][X])
